<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itwillbs.with_me.mapper.AdminStoreMapper">
<!-- 동적 SQL 기능 활용하여 SQL 구문을 다르게 구성 가능 
	FROM 절 이후의 검색타입과 검색어에 따른 WHERE절을 다르게 구성
	
	[동적 SQL문]
	- 어떤 조건에 따라 실행할 SQL 문장을 다르게 구성한 SQL 구문
	- JSTL에서 조건에 따라 문장을 다르게 실행하는 것과 거의 동일
		<c:if>, <c:choose><c:when><c:otherwise> => c: 제거하면 거의 동일
		
	조건1) 검색어(searchKeyword)가 널스트링이 아닐 때 WHERE 절 추가 => if 태그 필요
	조건2) 검색어가 있을 경우 WHERE 절 뒷 부분에 검색타입(searchType)에 따라 컬럼명 다르게 검색
			=> 복수개의 조건에 따른 동적 SQL 문을 작성하기 위해 choose, when, otherwise 태그 필요
			
	=> 결론> 테이블명, LIKE 절 등에 전달되는 데이터는 ${} 사용하고
	외부로부터 입력받는 대부분의 데이터는 #{} 사용하자!
	=> 결론2> LIKE절에 % 결합 시 CONCAT() 함수 활용하자

 -->
<!--  1. 검색어(searchKeyword)가 널스트리잉 아닐 때 검색어를 추가하기 위한 WHERE 절 추가
=> 검색어 데이터는 searchKeyword 변수에 저장되어 있으므로 변수명 그대로 활용
=> 자바 문법과 동일하게 equals() 메서드를 통해 문자열 비교 수행 -->
	
	<insert id="insertProduct">
		<selectKey keyProperty="product_idx" resultType="int" order="BEFORE">
			SELECT IFNULL(MAX(product_idx), 0) -- product_idx 최대값 조회(null 일 경우 기본값 0 사용)
			FROM product_info
		</selectKey>
		
		<!-- 새 글 번호와 참조글 번호는 <selectKey> 를 통회 조회한 #{product_idx} 값 사용 -->
		INSERT
		INTO product_info
		VALUES (
			#{product_idx} + 1        -- selectKey 를 통회 조회된 게시물 번호 + 1 값 사용
			, #{product_code}
			, #{product_name}
			, #{product_description}
			, #{product_category}
			, #{project_category_detail}
			, #{product_price}
			, #{product_stock}
			, 1                       -- 1 : 판매중, 2: 판매 중지, 3 : 품절
			, #{product_img}
			, now()
		)
	</insert>
	
</mapper>








